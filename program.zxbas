const GRID_WIDTH as ubyte = 31 ' 31 character columns available
const GRID_HEIGHT as ubyte = 22 ' 22 character rows available

' possible cell states stored in _grid
const CELL_DEAD as ubyte = 0 ' cell was dead, still is dead
const CELL_LIVES as ubyte = 1 ' cell was alive, still is alive
const CELL_BORN as ubyte = 2 ' cell was dead, is now alive
const CELL_DIES as ubyte = 3 ' cell was alive, is not dead
' adding this to a cell state marks it as active
const CELL_ACTIVE as ubyte = 4

dim _grid(GRID_WIDTH, GRID_HEIGHT) as ubyte

sub drawGrid()
    dim x as ubyte = 0
    dim y as ubyte = 0
    dim x2 as byte = 0
    dim y2 as byte = 0
    for x = 0 to GRID_WIDTH step 1
        for y = 0 to GRID_HEIGHT step 1
            if (_grid(x, y) mod CELL_ACTIVE = CELL_BORN or _grid(x, y) mod CELL_ACTIVE = CELL_DIES) then                
                ' update UI and move cell to settled state for next iteration
                if (_grid(x, y) mod CELL_ACTIVE = CELL_BORN) then                
                    print at y, x; "\::"
                    let _grid(x, y) = CELL_LIVES
                else if (_grid(x, y) mod CELL_ACTIVE = CELL_DIES) then
                    print at y, x; " "
                    let _grid(x, y) = CELL_DEAD
                end if 
                ' cell has changed so mark its neighbours as active
                for x2 = x - 1 to x + 1 step 1
                    if (x2 >= 0 and x2 <= GRID_WIDTH) then
                        for y2 = y - 1 to y + 1 step 1
                            if (y2 >= 0 and y2 <= GRID_HEIGHT and (x2 <> x or y2 <> y) and _grid(x2, y2) < CELL_ACTIVE) then
                                let _grid(x2, y2) = _grid(x2, y2) + CELL_ACTIVE
                            end if
                        next y2
                    end if
                next x2
            end if      
        next y
    next x
end sub

function wasCellAlive(x as ubyte, y as ubyte) as ubyte
    if (_grid(x, y) mod CELL_ACTIVE = CELL_LIVES or _grid(x, y) mod CELL_ACTIVE = CELL_DIES) then
        return 1
    end if
    return 0
end function

function getCellState(x as ubyte, y as ubyte) as ubyte
    dim total as ubyte = 0
    dim x2 as byte = 0
    dim y2 as byte = 0
    for x2 = x - 1 to x + 1 step 1
        if (x2 >= 0 and x2 <= GRID_WIDTH) then
            for y2 = y - 1 to y + 1 step 1
                if (y2 >= 0 and y2 <= GRID_HEIGHT and (x2 <> x or y2 <> y) and wasCellAlive(x2, y2) = 1) then
                    let total = total + 1
                end if
            next y2
        end if
    next x2

    dim wasAlive as ubyte = wasCellAlive(x, y)
    if (wasAlive = 1 and total > 1 and total < 4) then
        return CELL_LIVES
    else if (wasAlive = 0 and total = 3) then
        return CELL_BORN
    else if (wasAlive = 0) then
        return CELL_DEAD
    end if
    return CELL_DIES
end function

sub iterateGrid()
    for x = 0 to GRID_WIDTH step 1
        for y = 0 to GRID_HEIGHT step 1
            if (_grid(x, y) >= CELL_ACTIVE) then
                let _grid(x, y) = getCellState(x, y)
            end if
        next y
    next x    
end sub

sub createGliderAt(x as ubyte, y as ubyte)
    let _grid(x + 1, y) = CELL_BORN
    let _grid(x + 2, y + 1) = CELL_BORN
    let _grid(x, y + 2) = CELL_BORN
    let _grid(x + 1, y + 2) = CELL_BORN
    let _grid(x + 2, y + 2) = CELL_BORN
end sub

createGliderAt(0, 0)
createGliderAt(5, 5)
createGliderAt(10, 10)
createGliderAt(15, 15)
do
drawGrid()
iterateGrid()
loop: