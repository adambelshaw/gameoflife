const GRID_WIDTH as ubyte = 31 ' 31 character columns available
const GRID_HEIGHT as ubyte = 22 ' 22 character rows available
const MAX_UPDATED_CELLS as ubyte = 50
const MAX_ACTIVE_CELLS as ubyte = 200

' possible cell states stored in _grid
const CELL_DEAD as ubyte = 0 ' cell was dead, still is dead
const CELL_LIVES as ubyte = 1 ' cell was alive, still is alive
const CELL_BORN as ubyte = 2 ' cell was dead, is now alive
const CELL_DIES as ubyte = 3 ' cell was alive, is not dead
' adding this to a cell state marks it as active
const CELL_ACTIVE as ubyte = 4

dim _grid(GRID_WIDTH, GRID_HEIGHT) as ubyte
dim _updatedCellCount as uinteger = 0
dim _updatedCells(MAX_UPDATED_CELLS) as uinteger
dim _activeCellCount as uinteger = 0
dim _activeCells(MAX_ACTIVE_CELLS) as uinteger

function getCellLocation(x as ubyte, y as ubyte) as uinteger
    dim cellLocation as uinteger = GRID_WIDTH
    let cellLocation = cellLocation * y
    let cellLocation = cellLocation + x + 1
    return cellLocation
end function

function getCellXCoord(cellLocation as uinteger) as ubyte
    return (cellLocation mod GRID_WIDTH) - 1
end function

function getCellYCoord(cellLocation as uinteger) as ubyte
    return cellLocation / GRID_WIDTH
end function

sub drawGrid()
    let _activeCellCount = 0
    dim i as uinteger = 0    
    for i = 0 to _updatedCellCount step 1
        dim cellLocation as uinteger = _updatedCells(i)
        dim x as ubyte = getCellXCoord(cellLocation)
        dim y as ubyte = getCellYCoord(cellLocation)

        ' update UI and move cell to settled state for next iteration
        if (_grid(x, y) mod CELL_ACTIVE = CELL_BORN) then                
            print at y, x; "\::"
            let _grid(x, y) = CELL_LIVES
        else if (_grid(x, y) mod CELL_ACTIVE = CELL_DIES) then
            print at y, x; " "
            let _grid(x, y) = CELL_DEAD
        end if 

        ' cell has changed so mark its neighbours as active
        dim x2 as byte = 0    
        dim y2 as byte = 0
        for x2 = x - 1 to x + 1 step 1
            if (x2 >= 0 and x2 <= GRID_WIDTH) then
                for y2 = y - 1 to y + 1 step 1
                    if (y2 >= 0 and y2 <= GRID_HEIGHT and (x2 <> x or y2 <> y) and _grid(x2, y2) < CELL_ACTIVE and _activeCellCount < MAX_ACTIVE_CELLS) then
                        let _activeCells(_activeCellCount) = getCellLocation(x2, y2)
                        let _activeCellCount = _activeCellCount + 1
                        let _grid(x2, y2) = _grid(x2, y2) + CELL_ACTIVE
                    end if
                next y2
            end if
        next x2
    next i
end sub

function wasCellAlive(x as ubyte, y as ubyte) as ubyte
    if (_grid(x, y) mod CELL_ACTIVE = CELL_LIVES or _grid(x, y) mod CELL_ACTIVE = CELL_DIES) then
        return 1
    end if
    return 0
end function

function getCellState(x as ubyte, y as ubyte) as ubyte
    dim total as ubyte = 0
    dim x2 as byte = 0
    dim y2 as byte = 0
    for x2 = x - 1 to x + 1 step 1
        if (x2 >= 0 and x2 <= GRID_WIDTH) then
            for y2 = y - 1 to y + 1 step 1
                if (y2 >= 0 and y2 <= GRID_HEIGHT and (x2 <> x or y2 <> y) and wasCellAlive(x2, y2) = 1) then
                    let total = total + 1
                end if
            next y2
        end if
    next x2

    dim wasAlive as ubyte = wasCellAlive(x, y)
    if (wasAlive = 1 and total > 1 and total < 4) then
        return CELL_LIVES
    else if (wasAlive = 0 and total = 3) then
        return CELL_BORN
    else if (wasAlive = 0) then
        return CELL_DEAD
    end if
    return CELL_DIES
end function

sub iterateGrid()
    let _updatedCellCount = 0
    dim i as uinteger = 0
    for i = 0 to _activeCellCount step 1
        dim cellLocation as uinteger = _activeCells(i)
        dim x as ubyte = getCellXCoord(cellLocation)
        dim y as ubyte = getCellYCoord(cellLocation)
        let _grid(x, y) = getCellState(x, y)
        if ((_grid(x, y) = CELL_BORN or _grid(x, y) = CELL_DIES) and _updatedCellCount < MAX_UPDATED_CELLS) then
            let _updatedCells(_updatedCellCount) = cellLocation
            let _updatedCellCount = _updatedCellCount + 1
        end if
    next i  
end sub

sub addCell(x as ubyte, y as ubyte)
    if (_updatedCellCount < MAX_UPDATED_CELLS) then
        let _grid(x, y) = CELL_BORN
        let _updatedCells(_updatedCellCount) = getCellLocation(x, y)
        let _updatedCellCount = _updatedCellCount + 1
    end if
end sub

sub createGliderAt(x as ubyte, y as ubyte)
    addCell(x + 1, y)
    addCell(x + 2, y + 1)
    addCell(x, y + 2)
    addCell(x + 1, y + 2)
    addCell(x + 2, y + 2)
end sub

createGliderAt(0, 0)
createGliderAt(5, 5)
createGliderAt(10, 10)
createGliderAt(15, 15)
do
drawGrid()
iterateGrid()
loop: